"""
skills/plugins/dev_readme_gen.py — Developer: README Generator

Scans a project directory and generates a README.md scaffold by inspecting
structure, language, dependencies, and existing docs. Pure analysis — no LLM.

Risk: LOW — fs:read, fs:write
"""
from __future__ import annotations
import asyncio, json, time
from pathlib import Path
from typing import ClassVar
from neuralclaw.skills.base import SkillBase
from neuralclaw.skills.types import RiskLevel, SkillManifest, SkillResult, SkillValidationError

class DevReadmeGenSkill(SkillBase):
    manifest: ClassVar[SkillManifest] = SkillManifest(
        name="dev_readme_gen",
        version="1.0.0",
        description="Generate a README.md scaffold for a project by analysing its structure, language, and dependencies. Writes the file and returns the content.",
        category="developer",
        risk_level=RiskLevel.LOW,
        capabilities=frozenset({"fs:read","fs:write"}),
        timeout_seconds=20,
        parameters={"type":"object","properties":{
            "project_path":{"type":"string","description":"Path to the project root."},
            "output_path":{"type":"string","description":"Where to write README.md (default: <project_path>/README.md).","default":""},
            "overwrite":{"type":"boolean","description":"Overwrite existing README.md (default false).","default":False},
        },"required":["project_path"]},
    )

    async def validate(self, project_path: str, **_) -> None:
        if not Path(project_path).expanduser().exists():
            raise SkillValidationError(f"Project path does not exist: '{project_path}'")

    async def execute(self, project_path: str, output_path: str="", overwrite: bool=False, **kwargs) -> SkillResult:
        call_id = kwargs.get("_skill_call_id","")
        t_start = time.monotonic()
        proj = Path(project_path).expanduser().resolve()
        out = Path(output_path).expanduser() if output_path else proj/"README.md"

        if out.exists() and not overwrite:
            return SkillResult.fail(self.manifest.name, call_id, f"README.md already exists at '{out}'. Use overwrite=true to replace.", "FileExistsError")

        def _generate() -> str:
            name = proj.name
            # Detect language/framework
            langs = []
            if (proj/"pyproject.toml").exists() or (proj/"setup.py").exists() or list(proj.glob("*.py")): langs.append("Python")
            if (proj/"package.json").exists(): langs.append("Node.js")
            if (proj/"go.mod").exists(): langs.append("Go")
            if (proj/"Cargo.toml").exists(): langs.append("Rust")
            if (proj/"pom.xml").exists(): langs.append("Java")

            # Detect test framework
            test_cmd = "pytest" if "Python" in langs else "npm test" if "Node.js" in langs else "make test"

            # Detect install instructions
            if "Python" in langs:
                install = "```bash\npip install -r requirements.txt\n```"
                run = "```bash\npython main.py\n```"
            elif "Node.js" in langs:
                install = "```bash\nnpm install\n```"
                run = "```bash\nnpm start\n```"
            else:
                install = "```bash\n# See project documentation\n```"
                run = "```bash\n# See project documentation\n```"

            # Count files
            py_files = list(proj.rglob("*.py"))
            file_count = len(py_files)

            # Check for existing docs
            has_license = (proj/"LICENSE").exists() or (proj/"LICENSE.md").exists()
            has_changelog = (proj/"CHANGELOG.md").exists()

            sections = [
                f"# {name}\n",
                f"> *Generated by NeuralClaw dev_readme_gen — fill in the blanks below.*\n",
                f"## Overview\n\n{name} is a {', '.join(langs) or 'software'} project.\n\n<!-- TODO: Add a one-sentence description here -->\n",
                f"## Features\n\n- <!-- TODO: List key features -->\n",
                f"## Installation\n\n{install}\n",
                f"## Usage\n\n{run}\n\n<!-- TODO: Add usage examples -->\n",
                f"## Testing\n\n```bash\n{test_cmd}\n```\n",
                f"## Project Structure\n\n```\n{name}/\n├── <!-- TODO: describe structure -->\n```\n",
            ]
            if has_changelog: sections.append("## Changelog\n\nSee [CHANGELOG.md](CHANGELOG.md).\n")
            if has_license: sections.append("## License\n\nSee [LICENSE](LICENSE).\n")
            else: sections.append("## License\n\n<!-- TODO: Add license -->\n")
            return "\n".join(sections)

        try:
            loop = asyncio.get_event_loop()
            content = await loop.run_in_executor(None, _generate)
            def _write(): out.write_text(content)
            await loop.run_in_executor(None, _write)
            duration_ms = (time.monotonic()-t_start)*1000
            return SkillResult.ok(self.manifest.name, call_id,
                {"output_path":str(out),"char_count":len(content),"content":content}, duration_ms=duration_ms)
        except BaseException as e:
            return SkillResult.fail(self.manifest.name, call_id, f"{type(e).__name__}: {e}", type(e).__name__,
                                    duration_ms=(time.monotonic()-t_start)*1000)
